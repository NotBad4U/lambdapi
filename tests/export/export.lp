// .  ======================= Prop

constant symbol Prop : TYPE;

builtin "Prop" â‰” Prop;

// interpretation of propositions in TYPE

injective symbol Ï€ : Prop â†’ TYPE; // `p

builtin "P" â‰” Ï€;

// true

constant symbol âŠ¤ : Prop; // \top

constant symbol top : Ï€ âŠ¤;

// false

constant symbol âŠ¥ : Prop; // \bot

constant symbol âŠ¥â‚‘ [p: Prop] : Ï€ âŠ¥ â†’ Ï€ p;

// implication

constant symbol â‡’ : Prop â†’ Prop â†’ Prop; notation â‡’ infix right 5; // =>

rule Ï€ ($p â‡’ $q) â†ª Ï€ $p â†’ Ï€ $q;

symbol fold_â‡’ [p q: Prop] : Ï€ (p â‡’ q) â†’ Ï€ p â†’ Ï€ q â‰”
begin
  assume p q pq h; apply pq h;
end;

// negation

symbol Â¬ p â‰” p â‡’ âŠ¥; // ~~ or \neg

// conjunction

constant symbol âˆ§ : Prop â†’ Prop â†’ Prop; notation âˆ§ infix left 7; // /\ or \wedge

constant symbol âˆ§áµ¢ [p q: Prop] : Ï€ p â†’ Ï€ q â†’ Ï€ (p âˆ§ q);
symbol âˆ§â‚‘â‚ [p q: Prop] : Ï€ (p âˆ§ q) â†’ Ï€ p;
symbol âˆ§â‚‘â‚‚ [p q: Prop ] : Ï€ (p âˆ§ q) â†’ Ï€ q;

// disjunction

constant symbol âˆ¨ : Prop â†’ Prop â†’ Prop; notation âˆ¨ infix left 6; // \/ or \vee

constant symbol âˆ¨áµ¢â‚ [p q: Prop] : Ï€ p â†’ Ï€ (p âˆ¨ q);
constant symbol âˆ¨áµ¢â‚‚ [p q: Prop] : Ï€ q â†’ Ï€ (p âˆ¨ q);
symbol âˆ¨â‚‘ [p q r : Prop] : Ï€ (p âˆ¨ q) â†’ (Ï€ p â†’ Ï€ r) â†’ (Ï€ q â†’ Ï€ r) â†’ Ï€ r;

// check that priorities are correctly set
assert x y z âŠ¢ x âˆ¨ y âˆ§ z â‰¡ x âˆ¨ (y âˆ§ z);

// equivalence

symbol â‡” (p q: Prop) â‰” (p â‡’ q) âˆ§ (q â‡’ p); notation â‡” infix right 5;

opaque symbol â‡”_refl [p: Prop] : Ï€ (p â‡” p) â‰”
begin
  assume p; apply âˆ§áµ¢ { assume h; apply h } { assume h; apply h }
end;

opaque symbol â‡”_sym [p q: Prop] : Ï€ (p â‡” q) â†’ Ï€ (q â‡” p) â‰”
begin
  assume p q h; apply âˆ§áµ¢ { apply âˆ§â‚‘â‚‚ h } { apply âˆ§â‚‘â‚ h };
end;

debug +t;

opaque symbol â‡”_trans (p q r: Prop) : Ï€ (p â‡” q) â†’ Ï€ (q â‡” r) â†’ Ï€ (p â‡” r) â‰”
begin
  assume p q r epq eqr; apply âˆ§áµ¢
    {
        assume hp;
        apply âˆ§â‚‘â‚ eqr _;
        apply âˆ§â‚‘â‚ epq hp;
    }
    { assume hr; apply âˆ§â‚‘â‚‚ epq _; apply âˆ§â‚‘â‚‚ eqr hr };
end;

// Set ====================================


// Type of set codes for quantifying over sets (polymorphism)

constant symbol Set : TYPE;

// Interpretation of set codes in TYPE

injective symbol Ï„ : Set â†’ TYPE; // `t or \tau

builtin "T" â‰” Ï„;

// Cartesian product

constant symbol Ã— : Set â†’ Set â†’ Set; notation Ã— infix right 10; // \times

assert a b c âŠ¢ a Ã— b Ã— c â‰¡ a Ã— (b Ã— c);

symbol & [a b] : Ï„ a â†’ Ï„ b â†’ Ï„ (a Ã— b); notation & infix right 30;

assert a (x:Ï„ a) b (y:Ï„ b) c (z:Ï„ c) âŠ¢ x & y & z : Ï„(a Ã— b Ã— c);
assert x y z âŠ¢ x & y & z â‰¡ x & (y & z);

symbol â‚ [a b] : Ï„(a Ã— b) â†’ Ï„ a; notation â‚ postfix 10;

rule ($x & _)â‚ â†ª $x;

symbol â‚‚ [a b] : Ï„(a Ã— b) â†’ Ï„ b; notation â‚‚ postfix 10;

rule (_ & $x)â‚‚ â†ª $x;

constant symbol = [a] : Ï„ a â†’ Ï„ a â†’ Prop;

notation = infix 10;

constant symbol eq_refl [a] (x:Ï„ a) : Ï€ (x = x);
constant symbol ind_eq [a] [x y:Ï„ a] : Ï€ (x = y) â†’ Î  p, Ï€ (p y) â†’ Ï€ (p x);

builtin "eq"    â‰” =;
builtin "refl"  â‰” eq_refl;
builtin "eqind" â‰” ind_eq;

symbol â‰  [a] (x y : Ï„ a) â‰” Â¬ (x = y); notation â‰  infix 10; // \neq

opaque symbol feq [a b] (f:Ï„ a â†’ Ï„ b) [x x':Ï„ a] : Ï€(x = x') â†’ Ï€(f x = f x') â‰”
begin
  assume a b f x x' xx'; rewrite xx'; reflexivity;
end;

opaque symbol feq2 [a b c] (f:Ï„ a â†’ Ï„ b â†’ Ï„ c):
  Î  [x x':Ï„ a], Ï€(x = x') â†’ Î  [y y':Ï„ b], Ï€(y = y') â†’ Ï€(f x y = f x' y') â‰”
begin
  assume a b c f x x' xx' y y' yy'; rewrite xx'; rewrite yy'; reflexivity
end;

opaque symbol eq_sym [a] [x y:Ï„ a] : Ï€(x = y) â†’ Ï€(y = x) â‰”
begin
  assume a x y h; symmetry; apply h
end;


// Universal quantification

constant symbol âˆ€ [a] : (Ï„ a â†’ Prop) â†’ Prop; notation âˆ€ quantifier; // !! or \forall

rule Ï€ (âˆ€ $f) â†ª Î  x, Ï€ ($f x);

// Existential quantification

constant symbol âˆƒ [a] : (Ï„ a â†’ Prop) â†’ Prop; notation âˆƒ quantifier; // ?? or \exists

constant symbol âˆƒáµ¢ [a] p (x:Ï„ a) : Ï€ (p x) â†’ Ï€ (âˆƒ p);
symbol âˆƒâ‚‘ [a] p : Ï€ (âˆƒ p) â†’ Î  q, (Î  x:Ï„ a, Ï€ (p x) â†’ Ï€ q) â†’ Ï€ q;

rule âˆƒâ‚‘ _ (âˆƒáµ¢ _ $x $px) _ $f â†ª $f $x $px;


// ===========================

inductive ğ”¹ : TYPE â‰” // `dB or \BbbB
| true : ğ”¹
| false : ğ”¹;

constant symbol bool : Set;

rule Ï„ bool â†ª ğ”¹;

// induction principle with equalities

opaque symbol case_ğ”¹ (b: Ï„ bool) : Ï€ (b = true âˆ¨ b = false) â‰”
begin
  induction
  { apply âˆ¨áµ¢â‚; reflexivity; }
  { apply âˆ¨áµ¢â‚‚; reflexivity; }
end;

opaque symbol ind_ğ”¹_eq (p: Ï„ bool â†’ Prop) (b: Ï„ bool) :
 (Ï€(b = true) â†’ Ï€(p b)) â†’ (Ï€(b = false) â†’ Ï€(p b)) â†’ Ï€(p b) â‰”
begin
  assume p b t f; refine âˆ¨â‚‘ (case_ğ”¹ b) t f;
end;

// non confusion of constructors

symbol istrue : ğ”¹ â†’ Prop;

rule istrue true â†ª âŠ¤
with istrue false â†ª âŠ¥;

opaque symbol falseâ‰ true : Ï€ (false â‰  true) â‰”
begin
  assume h;
  type (ind_eq h );
  refine ind_eq h istrue top
end;

opaque symbol trueâ‰ false : Ï€ (true â‰  false) â‰”
begin
  assume h; apply falseâ‰ true; symmetry; apply h
end;

// not

symbol not : ğ”¹ â†’ ğ”¹;

rule not true  â†ª false
with not false â†ª true;

// or

symbol or : ğ”¹ â†’ ğ”¹ â†’ ğ”¹; notation or infix left 20;

rule true  or _     â†ª true
with _     or true  â†ª true
with false or $b    â†ª $b
with $b    or false â†ª $b;

opaque symbol âˆ¨_istrue [p q] : Ï€(istrue(p or q)) â†’ Ï€(istrue p âˆ¨ istrue q) â‰”
begin
  induction
  { assume q h; apply âˆ¨áµ¢â‚; apply top; }
  { assume q h; apply âˆ¨áµ¢â‚‚; apply h; }
end;

opaque symbol istrue_or [p q] : Ï€(istrue p âˆ¨ istrue q) â†’ Ï€(istrue(p or q)) â‰”
begin
  induction
  { assume q h; apply top; }
  { assume q h; apply âˆ¨â‚‘ h { assume i; apply âŠ¥â‚‘ i; } { assume i; apply i; } }
end;

opaque symbol oráµ¢â‚ [p] q : Ï€ (istrue p) â†’ Ï€ (istrue (p or q)) â‰”
begin
  induction
  { simplify; assume b h; apply top }
  { simplify; assume b h; apply âŠ¥â‚‘ h }
end;

opaque symbol oráµ¢â‚‚ p [q] : Ï€ (istrue q) â†’ Ï€ (istrue (p or q)) â‰”
begin
  induction
  { simplify; assume b h; apply top }
  { simplify; assume b h; apply h }
end;

opaque symbol orâ‚‘ [p q] r : Ï€(istrue(p or q)) â†’
  (Ï€(istrue p) â†’ Ï€(istrue r)) â†’ (Ï€(istrue q) â†’ Ï€(istrue r)) â†’ Ï€(istrue r) â‰”
begin
  assume p q r pq pr qr;
  have h: Ï€(istrue p âˆ¨ istrue q) { apply @âˆ¨_istrue p q pq /*FIXME*/ };
  apply âˆ¨â‚‘ h pr qr;
end;

opaque symbol orC p q : Ï€ (p or q = q or p) â‰”
begin
    induction
    { reflexivity; }
    { reflexivity; }
end;

opaque symbol orA p q r : Ï€ ((p or q) or r = p or (q or r)) â‰”
begin
    induction
    { reflexivity; }
    { reflexivity; }
end;

// and

symbol and : ğ”¹ â†’ ğ”¹ â†’ ğ”¹; notation and infix left 7;

rule true  and $b    â†ª $b
with $b    and true  â†ª $b
with false and _     â†ª false
with _     and false â†ª false;

opaque symbol âˆ§_istrue [p q] : Ï€(istrue (p and q)) â†’ Ï€(istrue p âˆ§ istrue q) â‰”
begin
  induction
  { induction
    { assume h; apply âˆ§áµ¢ { apply top } { apply top } }
    { assume h; apply âŠ¥â‚‘ h; }
  }
  { assume q h; apply âŠ¥â‚‘ h; }
end;

opaque symbol istrue_and [p q] : Ï€(istrue p âˆ§ istrue q) â†’ Ï€(istrue (p and q)) â‰”
begin
  induction
  { assume q h; apply âˆ§â‚‘â‚‚ h; }
  { assume q h; apply âˆ§â‚‘â‚ h; }
end;

opaque symbol andáµ¢ [p q] : Ï€(istrue p) â†’ Ï€(istrue q) â†’ Ï€(istrue (p and q)) â‰”
begin
  assume p q h i; //FIXME: apply istrue_and fails
  apply @istrue_and p q; apply âˆ§áµ¢ h i;
end;

opaque symbol andâ‚‘â‚ [p q] : Ï€ (istrue (p and q)) â†’ Ï€ (istrue p) â‰”
begin
  induction
  { assume q i; apply top; }
  { assume q i; apply i; }
end;

opaque symbol andâ‚‘â‚‚ [p q] : Ï€ (istrue (p and q)) â†’ Ï€ (istrue q) â‰”
begin
  induction
  { assume q i; apply i; }
  { assume q i; apply âŠ¥â‚‘ i; }
end;

// if-then-else

symbol if : ğ”¹ â†’ Î  [a], Ï„ a â†’ Ï„ a â†’ Ï„ a;

rule if true  $x _ â†ª $x
with if false _ $y â†ª $y;